# План тестирования плагина Yandex Disk Sync

## 1. Цели и охват
- Проверить корректность вспомогательных утилит, логики чтения/записи индекса, построения и выполнения плана синхронизации.
- Убедиться, что учтены крайние случаи: пустые данные, конфликтные изменения, ограничения по размеру, сетевые ошибки.
- Поддерживаемый инструмент: Jest с моками Obsidian API и сетевых вызовов (`requestUrl`).

## 2. Общая стратегия
- **Юнит-тесты**: через прямой импорт `helpers` и инстанцирование `YandexDiskSyncPlugin` с замоканным `app` и `vault.adapter`.
- **Контролируемые моки**: 
  - `requestUrl` — имитировать успешные ответы, ошибки (429, 500, 403, сетевое исключение), бинарные данные.
  - `vault.adapter` — реализовать `exists`, `read`, `write`, `mkdir`, чтобы отслеживать обращения.
  - `vault` — обеспечить заглушки `getFiles`, `getAbstractFileByPath`, `create`, `createBinary`, `modify`, `delete`, событийные методы.
- **Покрываемость**: нацелиться на ключевые ветви (минимум 80% statements/branches в `main.js`).

## 3. Вспомогательные функции (`helpers`)
1. `globToRegExp`
   - Поддержка `*`, `**`, `?`, комбинаций.
   - Экранирование спецсимволов (`+.()[]`).
   - Пустая строка и строка с ведущим слешем.
2. `pathJoin`
   - Смешанные разделители `\`/`/`, пустые сегменты, ведущий/замыкающий слеш.
3. `normalizeRelPath`
   - Удаление ведущих `///`, замена обратных слешей.
4. `createEmptyIndex`
   - Возвращает новый объект (не ссылка).
5. `sanitizeIndexForHash`
   - Игнорирование не-объектов, сортировка ключей, отбрасывание поля `lastSyncAt`, если оно не строка.
6. `computeIndexHash`
   - Стабильность для эквивалентных структур, возврат `null` при ошибке сериализации (например, с циклической ссылкой через поддельный getter).
7. `pathJoin`/`normalizeRelPath` — поведение на `undefined`/`null` (должен приводить к пустой строке или броску).

## 4. Настройки и миграции
1. `loadSettings`
   - Базовая загрузка без сохранённых данных (используются `DEFAULT_SETTINGS`).
   - Применение `_autoVaultNameApplied` и изменение `vaultFolderName` с сохранением (`saveSettings` вызывается).
   - Слияние `_persistedExtra` при наличии лишних ключей.
   - Поведение при отсутствии адаптера (возврат пустого индекса).
2. `saveSettings`
   - Вызов `persistIndexIfNeeded`, корректная обработка ошибок `writeIndexFile` (логирование).
3. Пересохранение `indexMeta`, если контрольная сумма изменилась.

## 5. Работа с индексом
1. `getIndexFilePath` и `ensureIndexDir`
   - Проконтролировать, что директория создаётся только один раз, корректно кэшируется `_indexDirEnsured`.
2. `readIndexFile`
   - Файл отсутствует: возвращается пустой индекс и `existed: false`.
   - Файл с корректными данными: сохраняется `lastSyncAt`, не теряются поля `files`.
   - Файл с битым JSON: выдаётся предупреждение, возвращается пустой индекс, `existed: true`.
   - Исключение адаптера (например, чтение бросает) → лог и возврат пустого индекса.
3. `writeIndexFile`
   - Формируемый JSON содержит `version`, валидные строки дат и объекты `files`.
   - Ошибка записи приводит к логированию и сохранению `_indexFileKnownExists = false`.
4. `persistIndexIfNeeded`
   - Индекс не изменился → запись не выполняется.
   - Изменился `hash` → запись происходит один раз.
   - `_indexFileKnownExists = false`, адаптер сообщает, что файл есть → запись пропускается.

## 6. Область синхронизации и фильтры
1. `getSuggestedVaultFolderName`
   - Удаление недопустимых символов, fallback на `vault`.
2. `toLocalRel` / `fromLocalRel`
   - Без `localBasePath`, с `localBasePath`, частичное совпадение (не должен удалять лишние сегменты).
3. `inScope`
   - Файл строго внутри/на границе/вне базы.
4. `matchesIgnore`
   - Кэширование регулярных выражений, проверка нескольких шаблонов.
   - Пустой список `ignorePatterns`.
5. `allowRemoteItem`
   - Фильтрация по игнору, расширениям, лимиту размера, значениям `size` = `null`.

## 7. HTTP-клиент (`http`)
1. Ошибка без токена → исключение сразу, без попыток.
2. Успешный ответ JSON/текст, проверка заголовка авторизации.
3. Ответ 429 → задействован backoff, повторяется до успеха, обновляется статус бар (`Throttled`).
4. Ошибки с кодами из `noRetryStatuses` → выбрасываются без повторов.
5. Поведение при исчерпанных попытках (например, три 500 подряд).
6. Бинарный ответ (`isBinary = true`) → возвращается `arrayBuffer`.
7. Сохранение `lastHttpError`, обогащение сообщения исключения.

## 8. API Яндекс.Диска
1. `ydGetResource` формирует URL с параметрами и вызывает `http` один раз.
2. `ydListFolderRecursive`
   - Обычный каталог с файлами, вложенные папки (stack push), пагинация `offset/limit`.
   - Фильтрация `dir` (должны игнорироваться), сохранение `rel` через `remoteAbsToRel`.
3. `remoteAbsToRel`
   - Примеры для `app:/`, `disk:/`, `trash:/`; разный регистр; пустой base; base без алиаса.
   - Base без слеша и с ведущими слешами.

## 9. Построение плана синхронизации (`buildPlan`)
1. Базовый случай: синхронизация с пустыми индексами → план пуст.
2. Новый локальный файл (upload), новый удалённый файл (download).
3. Оба менялись → конфликт (при `two-way` + `strategy: duplicate`).
4. `strategy: newest-wins`
   - Local свежее → upload; удалённый свежее → download; разница < tolerance → upload.
5. `syncMode: upload`/`download`
   - Проверить, что соответствующие операции блокируются.
6. Политика удалений `mirror`
   - Удалён локальный файл без изменений удалённого → `remote-delete`.
   - Удалён удалённый без изменений локального → `local-delete`.
   - Если файл изменён после последнего индекса → гибкий отказ от удаления.
7. Ограничение `maxSizeMB` и `excludeExtensions` (файлы должны быть исключены из плана).
8. Кэш игноров в `matchesIgnore` влияет на `buildPlan` (игнорированные файлы исключаются).
9. Порядок приоритета операций по `rel` (конфликт > upload/download > delete).

## 10. Выполнение плана (`executePlan` и ниже)
1. Разделение операций по типам, создание задач с правильной очередью.
2. `runWithConcurrency`
   - Учитывает предел `limit`, корректно обновляет `reportOpStart`/`reportOpEnd` (замокать методы и проверять вызовы).
   - Обработка исключений в таске → логирование и `failed++`.
   - Прерывание при `currentRun.canceled = true`.
3. `uploadLocalFile`
   - Создание родительской директории, получение href, чтение бинарных данных, вызов `http PUT`.
   - Ошибка `ydEnsureFolder` не прерывает процесс (обёрнута в `catch`).
4. `downloadRemoteFile`
   - Существующий файл (`modifyBinary`), существующая папка (`createBinary` с добавлением имени), создание новых директорий (`ensureFolderForPath`).
5. `resolveConflictByDuplication`
   - Markdown → текстовые копии, бинарные → бинарные копии.
   - Существующие файлы → использование `modify`/`modifyBinary`.
   - Случай, когда `localTFile` отсутствует (например, удалён локально) — ожидать graceful fallback.
6. Обновление индекса после выполнения плана (`index.files`, `lastSyncAt`), повторное чтение удалённого списка при `remoteChanged`.

## 11. Логирование и статус
1. `startRun`, `setRunPlan`, `finishRun`
   - Корректные значения `currentRun.total`, `queued`, `counts`.
2. `updateStatusBar`
   - Без statusBar (null) — без ошибок.
   - Состояния `Running`, `Throttled`, `Error`, `Done` меняют классы.
3. `openProgress` повторно использует модалку.
4. `reportOpStart`/`reportOpEnd` — обновление `lastOps` (при лимите в 10 записей), подсчёт `done/failed`.

## 12. Диагностические модалки и копирование
1. `copyTextToClipboard` — успешное и неуспешное копирование (подменить `document.execCommand`).
2. `ProgressModal`
   - `onOpen` вызывает `render`, кнопка "Cancel" ставит `currentRun.canceled = true` и обновляет статус.
3. `DiagnosticsModal`
   - `setText` обновляет контент, кнопка "Copy all" триггерит `copyTextToClipboard`.

## 13. Негативные сценарии
- Сбой `requestUrl` (например, таймаут) → `http` логирует и выбрасывает.
- Ошибка при чтении локального файла во время `uploadLocalFile` → исключение должно логироваться, операция помечается как провалившаяся.
- Исключение при `ydListFolderRecursive` на одной из итераций → корректный выход с логом.

## 14. Интеграционные сквозные проверки
1. «Счастливый путь»:
   - В хранилище локальный файл, в облаке другой, синхронизация two-way, после выполнения запись индекса, `finishRun(true)`, статус `Done`.
2. «Dry-run»:
   - `syncNow(true)` → формируется модалка с текстом плана, `finishRun(true)` без выполнения операций.
3. Ошибка при построении плана (например, `listLocalFilesInScope` бросает) → `syncNow(false)` приводит к `finishRun(false)` и `Notice` с ошибкой.

## 15. Организационные моменты
- Добавить вспомогательные фабрики/фикстуры для генерации оргиндекса, локальных/удалённых файлов.
- Зарезервировать в `__tests__` подпапки (`__tests__/plugin/…`) для сценариев плагина, разделив на `helpers`, `index`, `plan`, `http` и т.д.
- Настроить покрытия в `package.json` (`npm test -- --coverage --watchAll=false` для CI) и контролировать метрики через `coverageThreshold` в `jest.config.js` после появления тестов.
- Автоматизировать мок времени (`jest.useFakeTimers().setSystemTime`) для предсказуемых значений `nowIso()` и конфликтных меток времени.

## 16. Приоритет реализации
1. Критические ветви синхронизации (`buildPlan`, `executePlan`, `http`).
2. Работа с индексом (устойчивость к повреждениям файлов).
3. Фильтры области/игноров.
4. UI/диагностика и второстепенные утилиты.
